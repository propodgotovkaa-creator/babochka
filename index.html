<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,height=device-height,initial-scale=1.0" />
<title>Genially: –†–µ–¥–∞–∫—Ç–æ—Ä ¬´–ù–∞–π–¥–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞¬ª</title>

<style>
  :root{
    --bg:#0b1020;
    --panel:rgba(20,24,40,.82);
    --line:rgba(255,255,255,.14);
    --txt:rgba(255,255,255,.92);
    --muted:rgba(255,255,255,.65);
    --btn:#2d6cdf;
    --btn2:#16a34a;
  }
  *{box-sizing:border-box}
  html,body{height:100%; margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; background:var(--bg); color:var(--txt);}
  .wrap{display:grid; grid-template-columns: 360px 1fr; height:100%;}

  .panel{
    background:var(--panel);
    border-right:1px solid var(--line);
    padding:14px;
    overflow:auto;
    backdrop-filter: blur(8px);
  }
  .panel h1{font-size:16px;margin:0 0 12px}
  .row{margin:10px 0}
  label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
  input[type="text"], input[type="number"], select, textarea{
    width:100%; padding:10px; border-radius:10px;
    border:1px solid var(--line); background:rgba(255,255,255,.06);
    color:var(--txt); outline:none;
  }
  input[type="range"]{width:100%}
  textarea{resize:vertical; min-height:80px}
  .two{display:grid; grid-template-columns: 1fr 1fr; gap:10px}
  .btns{display:flex; gap:10px; flex-wrap:wrap; margin-top:10px}
  button{
    border:0; border-radius:10px; padding:10px 12px; cursor:pointer;
    color:#fff; font-weight:700;
  }
  .b1{background:var(--btn)}
  .b2{background:var(--btn2)}
  .b3{background:rgba(255,255,255,.12); border:1px solid var(--line); color:var(--txt); font-weight:700}

  .stage{
    position:relative;
    background:
      linear-gradient(0deg, rgba(255,255,255,.04), rgba(255,255,255,.04)),
      repeating-linear-gradient(45deg, rgba(255,255,255,.035) 0 12px, rgba(255,255,255,.02) 12px 24px);
    overflow:hidden;
  }

  .progBadge{
    position:absolute; right:14px; top:14px; z-index:20;
    background:rgba(0,0,0,.45); border:1px solid rgba(255,255,255,.18);
    padding:6px 10px; border-radius:999px; font-size:12px; color:rgba(255,255,255,.9);
    backdrop-filter: blur(6px);
    pointer-events:none;
  }

  .hintBtn{
    position:absolute;
    right:64px; top:12px;
    z-index:26;
    width:38px; height:38px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.18);
    background:rgba(0,0,0,.35);
    color:rgba(255,255,255,.92);
    font-size:18px;
    cursor:pointer;
    display:flex; align-items:center; justify-content:center;
    backdrop-filter: blur(6px);
    box-shadow: 0 12px 30px rgba(0,0,0,.18);
    -webkit-tap-highlight-color: transparent;
  }
  .hintBtn:hover{ background:rgba(0,0,0,.45); }
  .hintBtn:active{ transform: translateY(1px); }
  .hintBtn:disabled{ opacity:.45; cursor:not-allowed; }

  .centerTask{
    position:absolute; left:50%; top:18px; transform:translateX(-50%);
    z-index:18;
    max-width:min(720px, calc(100% - 40px));
    background:rgba(0,0,0,.42);
    border:1px solid rgba(255,255,255,.18);
    border-radius:14px;
    padding:10px 14px;
    color:rgba(255,255,255,.95);
    font:700 14px/1.25 system-ui,-apple-system,Segoe UI,Roboto,Arial;
    text-align:center;
    backdrop-filter: blur(8px);
    pointer-events:none;
    box-shadow: 0 12px 30px rgba(0,0,0,.22);
  }

  .finalOverlay{
    position:absolute; inset:0; z-index:30;
    display:none;
    align-items:center;
    justify-content:center;
    padding:24px;
    background:rgba(0,0,0,.18);
    backdrop-filter: blur(2px);
  }
  .finalCard{
    max-width:min(760px, calc(100% - 40px));
    background:rgba(0,0,0,.55);
    border:1px solid rgba(255,255,255,.18);
    border-radius:18px;
    padding:18px 18px;
    color:rgba(255,255,255,.96);
    font:800 18px/1.25 system-ui,-apple-system,Segoe UI,Roboto,Arial;
    text-align:center;
    box-shadow: 0 18px 50px rgba(0,0,0,.28);
  }

  .target{
    position:absolute;
    width:46px; height:46px;
    cursor:pointer;
    user-select:none;
    z-index:25;
    -webkit-tap-highlight-color: transparent;
  }
  .target img{display:block;width:100%;height:100%;object-fit:contain}

  @keyframes fxFadeIn{from{opacity:0} to{opacity:1}}
  @keyframes fxPopIn{0%{opacity:0; transform:scale(.7)} 100%{opacity:1; transform:scale(1)}}
  @keyframes fxSlideIn{0%{opacity:0; transform:translateY(-10px)} 100%{opacity:1; transform:translateY(0)}}
  @keyframes fxWiggle{
    0%{opacity:0; transform:scale(.9) rotate(-4deg)}
    70%{opacity:1; transform:scale(1.02) rotate(2deg)}
    100%{opacity:1; transform:scale(1) rotate(0deg)}
  }
  @keyframes fxSoftFade{
    0%{opacity:0; transform:scale(.96)}
    100%{opacity:1; transform:scale(1)}
  }

  .fx-none{}
  .fx-fade{animation: fxFadeIn var(--dur,500ms) ease-out}
  .fx-pop{animation: fxPopIn var(--dur,500ms) cubic-bezier(.2,.8,.2,1)}
  .fx-slide{animation: fxSlideIn var(--dur,500ms) ease-out}
  .fx-wiggle{animation: fxWiggle var(--dur,650ms) cubic-bezier(.2,.8,.2,1)}
  .fx-softfade{animation: fxSoftFade var(--dur,1100ms) ease-out}

  @keyframes fxHintPulse{
    0%   { transform:scale(1);   opacity:1; filter:drop-shadow(0 0 0 rgba(120,220,255,0)); }
    20%  { transform:scale(1.25);opacity:1; filter:drop-shadow(0 0 14px rgba(120,220,255,.95)); }
    40%  { transform:scale(1);   opacity:.35; filter:drop-shadow(0 0 0 rgba(120,220,255,0)); }
    60%  { transform:scale(1.25);opacity:1; filter:drop-shadow(0 0 16px rgba(120,220,255,.98)); }
    80%  { transform:scale(1);   opacity:.35; filter:drop-shadow(0 0 0 rgba(120,220,255,0)); }
    100% { transform:scale(1);   opacity:1; filter:drop-shadow(0 0 0 rgba(120,220,255,0)); }
  }
  .target.fx-hint img{ animation: fxHintPulse 900ms ease-in-out 0s 2; }

  .codeBox{height:260px; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; line-height:1.35;}
</style>
</head>

<body>
<div class="wrap">

  <div class="panel">
    <h1>–†–µ–¥–∞–∫—Ç–æ—Ä ¬´–ù–∞–π–¥–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞¬ª</h1>

    <div class="row">
      <label>URL –∫–∞—Ä—Ç–∏–Ω–∫–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞</label>
      <input id="imgUrl" type="text" />
      <div id="imgStatus" style="font-size:12px;color:var(--muted);margin-top:6px"></div>
    </div>

    <div class="two">
      <div class="row">
        <label>–†–∞–∑–º–µ—Ä (px): <span id="sizeVal">46</span></label>
        <input id="size" type="range" min="18" max="220" value="46" />
      </div>
      <div class="row">
        <label>–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–∞—Ö–æ–¥–æ–∫ (—Ä–∞—É–Ω–¥–æ–≤)</label>
        <input id="rounds" type="number" min="1" max="99" value="7" />
      </div>
    </div>

    <div class="two">
      <div class="row">
        <label>–ê–Ω–∏–º–∞—Ü–∏—è –ø–æ—è–≤–ª–µ–Ω–∏—è</label>
        <select id="anim">
          <option value="none">–±–µ–∑ –∞–Ω–∏–º–∞—Ü–∏–∏</option>
          <option value="softfade" selected>soft fade (–º–µ–¥–ª–µ–Ω–Ω–æ)</option>
          <option value="fade">fade</option>
          <option value="pop">pop</option>
          <option value="slide">slide</option>
          <option value="wiggle">wiggle</option>
        </select>
      </div>
      <div class="row">
        <label>–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∞–Ω–∏–º–∞—Ü–∏–∏ (–º—Å)</label>
        <input id="dur" type="number" min="0" max="3000" value="1100" />
      </div>
    </div>

    <div class="row">
      <label>–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è / —Ç–µ–∫—Å—Ç –∑–∞–¥–∞–Ω–∏—è (–ø–ª–∞—à–∫–∞ —Å–≤–µ—Ä—Ö—É –ø–æ —Ü–µ–Ω—Ç—Ä—É)</label>
      <input id="taskText" type="text" value="–ù–∞–π–¥–∏ –±–∞–±–æ—á–∫—É –∏ –Ω–∞–∂–º–∏ –Ω–∞ –Ω–µ—ë!" />
    </div>

    <div class="row">
      <label>–¢–µ–∫—Å—Ç –≤ –∫–æ–Ω—Ü–µ –∏–≥—Ä—ã</label>
      <textarea id="endText">–ú–æ–ª–æ–¥–µ—Ü! –ü—Ä–∏—Ö–æ–¥–∏ –∏–≥—Ä–∞—Ç—å –µ—â—ë —Ä–∞–∑ üòä</textarea>
    </div>

    <div class="two">
      <div class="row">
        <label>–û—Ç—Å—Ç—É–ø –æ—Ç –∫—Ä–∞—ë–≤ (px)</label>
        <input id="pad" type="number" min="0" max="200" value="12" />
      </div>
      <div class="row">
        <label>–ü–∞—É–∑–∞ –º–µ–∂–¥—É —Ä–∞—É–Ω–¥–∞–º–∏ (–º—Å)</label>
        <input id="gap" type="number" min="0" max="8000" value="200" />
      </div>
    </div>

    <div class="btns">
      <button class="b3" id="reset">–°–±—Ä–æ—Å</button>
      <button class="b1" id="getCode">–ü–æ–ª—É—á–∏—Ç—å –∫–æ–¥</button>
      <button class="b2" id="copyCode">–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å –∫–æ–¥</button>
    </div>

    <div class="row">
      <label>–ö–æ–¥ –¥–ª—è –≤—Å—Ç–∞–≤–∫–∏ –≤ Genially (HTML / Embed)</label>
      <textarea id="code" class="codeBox" spellcheck="false"></textarea>
      <div style="font-size:12px;color:var(--muted);margin-top:6px">
        –í Genially –≤—Å—Ç–∞–≤–ª—è–π –≤ HTML/Embed.
      </div>
    </div>
  </div>

  <div class="stage" id="stage">
    <div class="progBadge" id="progBadge">0/7</div>
    <button class="hintBtn" id="hintBtn" title="–ü–æ–¥—Å–∫–∞–∑–∫–∞" aria-label="–ü–æ–¥—Å–∫–∞–∑–∫–∞">üí°</button>
    <div class="centerTask" id="centerTask">–ù–∞–π–¥–∏ –±–∞–±–æ—á–∫—É –∏ –Ω–∞–∂–º–∏ –Ω–∞ –Ω–µ—ë!</div>

    <div class="target fx-softfade" id="target" style="--dur:1100ms;">
      <img id="targetImg" alt="" />
    </div>

    <div class="finalOverlay" id="finalOverlay">
      <div class="finalCard" id="finalCard">–ú–æ–ª–æ–¥–µ—Ü! –ü—Ä–∏—Ö–æ–¥–∏ –∏–≥—Ä–∞—Ç—å –µ—â—ë —Ä–∞–∑ üòä</div>
    </div>
  </div>

</div>

<script>
  const $ = (id)=>document.getElementById(id);

  const DEFAULT_URL = "https://propodgotovkaa-creator.github.io/babochka/babochka.png";

  const imgUrl = $("imgUrl");
  const imgStatus = $("imgStatus");
  const size = $("size");
  const sizeVal = $("sizeVal");
  const rounds = $("rounds");
  const anim = $("anim");
  const dur = $("dur");
  const pad = $("pad");
  const gap = $("gap");
  const taskText = $("taskText");
  const endText = $("endText");

  const stage = $("stage");
  const target = $("target");
  const targetImg = $("targetImg");
  const progBadge = $("progBadge");
  const centerTask = $("centerTask");
  const hintBtn = $("hintBtn");

  const finalOverlay = $("finalOverlay");
  const finalCard = $("finalCard");

  const codeBox = $("code");

  let found = 0;
  let last = {x:null, y:null};

  // –ü–∞–º—è—Ç—å —è—á–µ–µ–∫ (—á—Ç–æ–±—ã –Ω–µ –ø–æ–≤—Ç–æ—Ä—è—Ç—å –º–µ—Å—Ç–∞)
  let usedCells = new Set();

  function clamp(n,a,b){ return Math.max(a, Math.min(b, n)); }

  function rect(){
    const r = stage.getBoundingClientRect();
    return {w: Math.max(1, r.width), h: Math.max(1, r.height)};
  }

  function setTargetSize(px){
    target.style.width = px + "px";
    target.style.height = px + "px";
    sizeVal.textContent = px;
  }

  function setAnim(){
    target.classList.remove("fx-none","fx-fade","fx-pop","fx-slide","fx-wiggle","fx-softfade");
    const v = anim.value;
    target.classList.add(v==="none" ? "fx-none" : ("fx-"+v));
    target.style.setProperty("--dur", Math.max(0, +dur.value || 0) + "ms");
  }

  function updateTexts(){
    centerTask.textContent = (taskText.value || "–ù–∞–π–¥–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞!").trim();
    finalCard.textContent = (endText.value || "–ú–æ–ª–æ–¥–µ—Ü!").trim();
  }

  function updateProgress(){
    const total = Math.max(1, +rounds.value || 1);
    progBadge.textContent = `${found}/${total}`;
  }

  function intersects(a, b){
    return !(a.x + a.w <= b.x || b.x + b.w <= a.x || a.y + a.h <= b.y || b.y + b.h <= a.y);
  }

  function toStageRect(el){
    if(!el) return null;
    const sr = stage.getBoundingClientRect();
    const r = el.getBoundingClientRect();
    return { x: r.left - sr.left, y: r.top - sr.top, w: r.width, h: r.height };
  }

  function getForbiddenRects(){
    const rects = [];
    const a = toStageRect(centerTask);
    const b = toStageRect(progBadge);
    const c = toStageRect(hintBtn);

    const pad = 10;
    for(const r of [a,b,c]){
      if(!r) continue;
      rects.push({ x: r.x - pad, y: r.y - pad, w: r.w + pad*2, h: r.h + pad*2 });
    }
    return rects;
  }

  // --- –ù–æ–≤—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º –±–µ–∑ –ø–æ–≤—Ç–æ—Ä–æ–≤ ---
  // –î–µ–ª–∏–º —Å—Ü–µ–Ω—É –Ω–∞ —Å–µ—Ç–∫—É; –≤—ã–±–∏—Ä–∞–µ–º —è—á–µ–π–∫—É, –∫–æ—Ç–æ—Ä—É—é –µ—â—ë –Ω–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏, –∏ —Å—Ç–∞—Ä–∞–µ–º—Å—è –≤—ã–±—Ä–∞—Ç—å –¥–∞–ª—å–Ω—é—é –æ—Ç last
  function pickCell(w,h,s,p,forbid){
    // –°–µ—Ç–∫–∞: –ø–æ–¥—Å—Ç—Ä–∞–∏–≤–∞–µ–º –ø–æ–¥ —Ä–∞–∑–º–µ—Ä (—á—Ç–æ–±—ã —è—á–µ–µ–∫ –±—ã–ª–æ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ)
    const cols = clamp(Math.floor(w / Math.max(140, s*2)), 4, 9);
    const rows = clamp(Math.floor(h / Math.max(120, s*2)), 3, 8);

    const minX = p, minY = p;
    const maxX = Math.max(minX, w - p - s);
    const maxY = Math.max(minY, h - p - s);

    const cellW = (maxX - minX) / cols;
    const cellH = (maxY - minY) / rows;

    const key = (cx,cy)=> `${cx},${cy}`;

    // —Å—Ñ–æ—Ä–º–∏—Ä—É–µ–º —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —è—á–µ–µ–∫ (–≥–¥–µ –≤–æ–æ–±—â–µ –º–æ–∂–Ω–æ –ø–æ—Å—Ç–∞–≤–∏—Ç—å —Å–ø—Ä–∞–π—Ç –±–µ–∑ –∑–∞–ø—Ä–µ—Ç–Ω—ã—Ö –∑–æ–Ω)
    const candidates = [];
    for(let cy=0; cy<rows; cy++){
      for(let cx=0; cx<cols; cx++){
        // —Ü–µ–Ω—Ç—Ä —è—á–µ–π–∫–∏
        const centerX = minX + (cx + 0.5) * cellW;
        const centerY = minY + (cy + 0.5) * cellH;
        const rectCandidate = { x: centerX - s/2, y: centerY - s/2, w:s, h:s };
        if(forbid.some(fr => intersects(rectCandidate, fr))) continue;
        candidates.push({cx,cy, centerX, centerY, k:key(cx,cy)});
      }
    }

    // –µ—Å–ª–∏ –≤—Å–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω—ã ‚Äî —Å–±—Ä–æ—Å (–∏–Ω–∞—á–µ –∏–≥—Ä–∞ –º–æ–∂–µ—Ç ‚Äú–∑–∞—Å—Ç—Ä—è—Ç—å‚Äù)
    const unused = candidates.filter(c => !usedCells.has(c.k));
    const pool = (unused.length ? unused : candidates);

    if(!pool.length){
      // –≤–æ–æ–±—â–µ –Ω–µ–≥–¥–µ (–æ—á–µ–Ω—å –º–∞–ª–µ–Ω—å–∫–∏–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä) ‚Äî –ø—É—Å—Ç—å fallback –±—É–¥–µ—Ç –æ–±—ã—á–Ω—ã–π —Ä–∞–Ω–¥–æ–º
      return {cols, rows, minX, minY, maxX, maxY, cellW, cellH, chosen:null};
    }

    // –≤—ã–±–∏—Ä–∞–µ–º "—Å–∞–º—É—é –¥–∞–ª—å–Ω—é—é" —è—á–µ–π–∫—É –æ—Ç last (–µ—Å–ª–∏ last –µ—Å—Ç—å), –∏–Ω–∞—á–µ —Å–ª—É—á–∞–π–Ω—É—é
    let best = pool[0];
    let bestScore = -1;
    for(const c of pool){
      const dx = (last.x === null) ? 0 : (c.centerX - last.x);
      const dy = (last.y === null) ? 0 : (c.centerY - last.y);
      const d = Math.hypot(dx,dy);
      // –Ω–µ–±–æ–ª—å—à–æ–π —Ä–∞–Ω–¥–æ–º —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ ‚Äú–æ–¥–Ω–æ –∏ —Ç–æ –∂–µ‚Äù –ø—Ä–∏ –æ–¥–∏–Ω–∞–∫–æ–≤—ã—Ö –¥–∏—Å—Ç–∞–Ω—Ü–∏—è—Ö
      const score = d + Math.random()*5;
      if(score > bestScore){
        bestScore = score;
        best = c;
      }
    }

    // –æ—Ç–º–µ—á–∞–µ–º —è—á–µ–π–∫—É –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω–æ–π (–µ—Å–ª–∏ –±—ã–ª –ø–æ–ª–Ω—ã–π –∫—Ä—É–≥ ‚Äî usedCells —É–∂–µ –Ω–µ —á–∏—Å—Ç–∏–º —Ç—É—Ç: –æ—á–∏—Å—Ç–∏–º –∫–æ–≥–¥–∞ —Ä–µ–∞–ª—å–Ω–æ –≤—Å–µ –∑–∞–Ω—è—Ç—ã)
    if(unused.length === 0){
      usedCells.clear();
    }
    usedCells.add(best.k);

    return {cols, rows, minX, minY, maxX, maxY, cellW, cellH, chosen:best};
  }

  function randomPos(){
    const {w,h} = rect();
    const s = parseFloat(target.style.width) || 46;
    const p = clamp(+pad.value || 0, 0, 240);
    const forbid = getForbiddenRects();

    const minX = p;
    const minY = p;
    const maxX = Math.max(minX, w - p - s);
    const maxY = Math.max(minY, h - p - s);

    // 1) –≤—ã–±–∏—Ä–∞–µ–º —è—á–µ–π–∫—É (–±–µ–∑ –ø–æ–≤—Ç–æ—Ä–æ–≤)
    const cell = pickCell(w,h,s,p,forbid);

    // 2) —Ç–æ—á–∫—É –≤–Ω—É—Ç—Ä–∏ —è—á–µ–π–∫–∏ –≤—ã–±–∏—Ä–∞–µ–º ‚Äú–ª—É—á—à–µ–µ –∏–∑ N‚Äù (—á—Ç–æ–±—ã –µ—â—ë –∏ –Ω–µ –ø–µ—Ä–µ—Å–µ–∫–∞–ª–æ –∑–∞–ø—Ä–µ—Ç—ã)
    const N = 30;
    const candidateRect = (pt) => ({ x: pt.x, y: pt.y, w: s, h: s });

    const randInBounds = () => ({
      x: minX + Math.random()*(maxX - minX),
      y: minY + Math.random()*(maxY - minY)
    });

    // –µ—Å–ª–∏ —è—á–µ–π–∫–∞ –Ω–µ –≤—ã–±—Ä–∞–Ω–∞ (–Ω–∞ —Å–æ–≤—Å–µ–º –º–∞–ª–µ–Ω—å–∫–æ–º –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–µ) ‚Äî –ø—Ä–æ—Å—Ç–æ–π —Ä–∞–Ω–¥–æ–º —Å –∑–∞—â–∏—Ç–æ–π
    if(!cell.chosen){
      for(let i=0;i<80;i++){
        const pt = randInBounds();
        if(!forbid.some(fr => intersects(candidateRect(pt), fr))){
          last = pt; return pt;
        }
      }
      const pt = randInBounds();
      last = pt; return pt;
    }

    const cx = cell.chosen.cx;
    const cy = cell.chosen.cy;

    const cellMinX = cell.minX + cx * cell.cellW;
    const cellMinY = cell.minY + cy * cell.cellH;
    const cellMaxX = Math.min(cell.maxX, cellMinX + cell.cellW);
    const cellMaxY = Math.min(cell.maxY, cellMinY + cell.cellH);

    let best = null;
    let bestD = -1;

    for(let i=0;i<N;i++){
      const pt = {
        x: cellMinX + Math.random()*Math.max(0, (cellMaxX - cellMinX)),
        y: cellMinY + Math.random()*Math.max(0, (cellMaxY - cellMinY))
      };
      const cr = candidateRect(pt);
      if(forbid.some(fr => intersects(cr, fr))) continue;

      const d = (last.x === null) ? 0 : Math.hypot(pt.x - last.x, pt.y - last.y);
      if(d > bestD){
        bestD = d;
        best = pt;
      }
    }

    // fallback ‚Äî –µ—Å–ª–∏ –≤–Ω—É—Ç—Ä–∏ —è—á–µ–π–∫–∏ –Ω–µ –ø–æ–ª—É—á–∏–ª–æ—Å—å, –ø–æ–ø—Ä–æ–±—É–µ–º –ø–æ –≤—Å–µ–º—É –ø–æ–ª—é
    if(!best){
      for(let i=0;i<120;i++){
        const pt = randInBounds();
        if(!forbid.some(fr => intersects(candidateRect(pt), fr))){
          best = pt; break;
        }
      }
    }

    if(!best) best = randInBounds();
    last = best;
    return best;
  }

  function place(){
    const pos = randomPos();
    target.style.left = pos.x + "px";
    target.style.top  = pos.y + "px";
  }

  function showFinal(){
    target.style.display = "none";
    finalOverlay.style.display = "flex";
    hintBtn.disabled = true;
  }

  function hideFinal(){
    finalOverlay.style.display = "none";
    hintBtn.disabled = false;
  }

  function next(){
    const total = Math.max(1, +rounds.value || 1);
    if(found >= total){
      showFinal();
      return;
    }
    hideFinal();
    target.style.display = "";

    target.classList.remove("fx-none","fx-fade","fx-pop","fx-slide","fx-wiggle","fx-softfade","fx-hint");
    void target.offsetWidth;

    setAnim();
    place();
    updateProgress();
  }

  function resetGame(){
    found = 0;
    last = {x:null,y:null};
    usedCells.clear();
    hideFinal();
    updateTexts();
    setTargetSize(+size.value || 46);
    setAnim();
    updateProgress();
    place();
    target.style.display = "";
  }

  function runHint(){
    if(finalOverlay.style.display === "flex") return;

    const wasHidden = (target.style.display === "none");
    if(wasHidden) target.style.display = "";

    target.classList.remove("fx-hint");
    void target.offsetWidth;
    target.classList.add("fx-hint");

    setTimeout(()=>{
      target.classList.remove("fx-hint");
      if(wasHidden) target.style.display = "none";
    }, 2000);
  }

  // --- –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–æ–¥–∞ –¥–ª—è Genially (—Ç–æ—Ç –∂–µ –∞–ª–≥–æ—Ä–∏—Ç–º –±–µ–∑ –ø–æ–≤—Ç–æ—Ä–æ–≤) ---
  function buildWidgetCode(cfg){
    const configJson = JSON.stringify(cfg);

    return `<div id="FX_ROOT">
  <style>
    #FX_ROOT{position:relative;width:100%;height:100%;overflow:hidden;background:transparent;}

    #FX_ROOT .fx_prog{
      position:absolute; right:14px; top:14px; z-index:999999;
      background:rgba(0,0,0,.45); border:1px solid rgba(255,255,255,.18);
      padding:6px 10px; border-radius:999px; font-size:12px; color:rgba(255,255,255,.9);
      backdrop-filter: blur(6px);
      pointer-events:none;
    }

    #FX_ROOT .fx_hintBtn{
      position:absolute; right:64px; top:12px;
      z-index:1000000;
      width:38px; height:38px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(0,0,0,.35);
      color:rgba(255,255,255,.92);
      font-size:18px;
      cursor:pointer;
      display:flex; align-items:center; justify-content:center;
      backdrop-filter: blur(6px);
      box-shadow: 0 12px 30px rgba(0,0,0,.18);
      -webkit-tap-highlight-color: transparent;
    }
    #FX_ROOT .fx_hintBtn:hover{ background:rgba(0,0,0,.45); }
    #FX_ROOT .fx_hintBtn:active{ transform: translateY(1px); }
    #FX_ROOT .fx_hintBtn:disabled{ opacity:.45; cursor:not-allowed; }

    #FX_ROOT .fx_task{
      position:absolute; left:50%; top:18px; transform:translateX(-50%);
      z-index:999998;
      max-width:min(720px, calc(100% - 40px));
      background:rgba(0,0,0,.42);
      border:1px solid rgba(255,255,255,.18);
      border-radius:14px;
      padding:10px 14px;
      color:rgba(255,255,255,.95);
      font:700 14px/1.25 system-ui,-apple-system,Segoe UI,Roboto,Arial;
      text-align:center;
      backdrop-filter: blur(8px);
      pointer-events:none;
      box-shadow: 0 12px 30px rgba(0,0,0,.22);
    }

    #FX_ROOT .fx_target{
      position:absolute; z-index:999999;
      width:48px; height:48px;
      cursor:pointer; user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    #FX_ROOT .fx_target img{display:block;width:100%;height:100%;object-fit:contain}

    #FX_ROOT .fx_final{
      position:absolute; inset:0; z-index:1000001;
      display:none; align-items:center; justify-content:center;
      padding:24px;
      background:rgba(0,0,0,.18);
      backdrop-filter: blur(2px);
      pointer-events:none;
    }
    #FX_ROOT .fx_finalCard{
      max-width:min(760px, calc(100% - 40px));
      background:rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.18);
      border-radius:18px;
      padding:18px 18px;
      color:rgba(255,255,255,.96);
      font:800 18px/1.25 system-ui,-apple-system,Segoe UI,Roboto,Arial;
      text-align:center;
      box-shadow: 0 18px 50px rgba(0,0,0,.28);
    }

    @keyframes fxFadeIn{from{opacity:0} to{opacity:1}}
    @keyframes fxPopIn{0%{opacity:0; transform:scale(.7)} 100%{opacity:1; transform:scale(1)}}
    @keyframes fxSlideIn{0%{opacity:0; transform:translateY(-10px)} 100%{opacity:1; transform:translateY(0)}}
    @keyframes fxWiggle{0%{opacity:0; transform:scale(.9) rotate(-4deg)} 70%{opacity:1; transform:scale(1.02) rotate(2deg)} 100%{opacity:1; transform:scale(1) rotate(0deg)}}
    @keyframes fxSoftFade{0%{opacity:0; transform:scale(.96)} 100%{opacity:1; transform:scale(1)}}

    #FX_ROOT .fx-none{}
    #FX_ROOT .fx-fade{animation: fxFadeIn var(--dur,500ms) ease-out}
    #FX_ROOT .fx-pop{animation: fxPopIn var(--dur,500ms) cubic-bezier(.2,.8,.2,1)}
    #FX_ROOT .fx-slide{animation: fxSlideIn var(--dur,500ms) ease-out}
    #FX_ROOT .fx-wiggle{animation: fxWiggle var(--dur,650ms) cubic-bezier(.2,.8,.2,1)}
    #FX_ROOT .fx-softfade{animation: fxSoftFade var(--dur,1100ms) ease-out}

    @keyframes fxHintPulse{
      0%   { transform:scale(1);   opacity:1; filter:drop-shadow(0 0 0 rgba(120,220,255,0)); }
      20%  { transform:scale(1.25);opacity:1; filter:drop-shadow(0 0 14px rgba(120,220,255,.95)); }
      40%  { transform:scale(1);   opacity:.35; filter:drop-shadow(0 0 0 rgba(120,220,255,0)); }
      60%  { transform:scale(1.25);opacity:1; filter:drop-shadow(0 0 16px rgba(120,220,255,.98)); }
      80%  { transform:scale(1);   opacity:.35; filter:drop-shadow(0 0 0 rgba(120,220,255,0)); }
      100% { transform:scale(1);   opacity:1; filter:drop-shadow(0 0 0 rgba(120,220,255,0)); }
    }
    #FX_ROOT .fx_target.fx-hint img{ animation: fxHintPulse 900ms ease-in-out 0s 2; }
  </style>

  <div class="fx_prog"></div>
  <button class="fx_hintBtn" type="button" aria-label="–ü–æ–¥—Å–∫–∞–∑–∫–∞" title="–ü–æ–¥—Å–∫–∞–∑–∫–∞">üí°</button>
  <div class="fx_task"></div>
  <div class="fx_target"><img alt=""></div>

  <div class="fx_final">
    <div class="fx_finalCard"></div>
  </div>

  <script>
  (function(){
    const root = document.getElementById('FX_ROOT');
    if(!root) return;

    const cfg = ${configJson};

    const progEl = root.querySelector('.fx_prog');
    const hintBtn = root.querySelector('.fx_hintBtn');
    const taskEl = root.querySelector('.fx_task');
    const target = root.querySelector('.fx_target');
    const img = target.querySelector('img');
    const final = root.querySelector('.fx_final');
    const finalCard = root.querySelector('.fx_finalCard');

    let found = 0;
    let last = {x:null, y:null};
    let usedCells = new Set();

    function clamp(n,a,b){ return Math.max(a, Math.min(b, n)); }
    function rect(){
      const r = root.getBoundingClientRect();
      return {w: Math.max(1, r.width), h: Math.max(1, r.height)};
    }
    function intersects(a, b){
      return !(a.x + a.w <= b.x || b.x + b.w <= a.x || a.y + a.h <= b.y || b.y + b.h <= a.y);
    }
    function toRootRect(el){
      if(!el) return null;
      const sr = root.getBoundingClientRect();
      const r = el.getBoundingClientRect();
      return { x: r.left - sr.left, y: r.top - sr.top, w: r.width, h: r.height };
    }
    function getForbiddenRects(){
      const rects = [];
      const a = toRootRect(taskEl);
      const b = toRootRect(progEl);
      const c = toRootRect(hintBtn);
      const pad = 10;
      for(const r of [a,b,c]){
        if(!r) continue;
        rects.push({ x: r.x - pad, y: r.y - pad, w: r.w + pad*2, h: r.h + pad*2 });
      }
      return rects;
    }

    function setAnim(){
      target.classList.remove('fx-none','fx-fade','fx-pop','fx-slide','fx-wiggle','fx-softfade','fx-hint');
      const v = cfg.anim || 'none';
      target.classList.add(v==='none' ? 'fx-none' : ('fx-'+v));
      target.style.setProperty('--dur', Math.max(0, cfg.dur|0) + 'ms');
    }

    function updateUI(){
      const total = Math.max(1, cfg.rounds|0);
      progEl.textContent = found + '/' + total;
      taskEl.textContent = (cfg.task || '–ù–∞–π–¥–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞!').trim();
      finalCard.textContent = (cfg.endText || '–ú–æ–ª–æ–¥–µ—Ü!').trim();
    }

    function pickCell(w,h,s,p,forbid){
      const cols = clamp(Math.floor(w / Math.max(140, s*2)), 4, 9);
      const rows = clamp(Math.floor(h / Math.max(120, s*2)), 3, 8);

      const minX = p, minY = p;
      const maxX = Math.max(minX, w - p - s);
      const maxY = Math.max(minY, h - p - s);

      const cellW = (maxX - minX) / cols;
      const cellH = (maxY - minY) / rows;

      const key = (cx,cy)=> cx + ',' + cy;

      const candidates = [];
      for(let cy=0; cy<rows; cy++){
        for(let cx=0; cx<cols; cx++){
          const centerX = minX + (cx + 0.5) * cellW;
          const centerY = minY + (cy + 0.5) * cellH;
          const rc = { x:centerX - s/2, y:centerY - s/2, w:s, h:s };
          if(forbid.some(fr => intersects(rc, fr))) continue;
          candidates.push({cx,cy, centerX, centerY, k:key(cx,cy)});
        }
      }

      const unused = candidates.filter(c => !usedCells.has(c.k));
      const pool = (unused.length ? unused : candidates);

      if(!pool.length){
        return {cols, rows, minX, minY, maxX, maxY, cellW, cellH, chosen:null};
      }

      let best = pool[0];
      let bestScore = -1;
      for(const c of pool){
        const dx = (last.x === null) ? 0 : (c.centerX - last.x);
        const dy = (last.y === null) ? 0 : (c.centerY - last.y);
        const d = Math.hypot(dx,dy);
        const score = d + Math.random()*5;
        if(score > bestScore){ bestScore = score; best = c; }
      }

      if(unused.length === 0) usedCells.clear();
      usedCells.add(best.k);

      return {cols, rows, minX, minY, maxX, maxY, cellW, cellH, chosen:best};
    }

    function randomPos(){
      const {w,h} = rect();
      const s = Math.max(1, cfg.size|0);
      const p = clamp(cfg.pad|0, 0, 240);
      const forbid = getForbiddenRects();

      const minX = p;
      const minY = p;
      const maxX = Math.max(minX, w - p - s);
      const maxY = Math.max(minY, h - p - s);

      const cell = pickCell(w,h,s,p,forbid);
      const candidateRect = (pt)=>({x:pt.x,y:pt.y,w:s,h:s});

      const randInBounds = ()=>({
        x: minX + Math.random()*(maxX - minX),
        y: minY + Math.random()*(maxY - minY)
      });

      if(!cell.chosen){
        for(let i=0;i<80;i++){
          const pt = randInBounds();
          if(!forbid.some(fr => intersects(candidateRect(pt), fr))){
            last = pt; return pt;
          }
        }
        const pt = randInBounds(); last = pt; return pt;
      }

      const cx = cell.chosen.cx, cy = cell.chosen.cy;
      const cellMinX = cell.minX + cx * cell.cellW;
      const cellMinY = cell.minY + cy * cell.cellH;
      const cellMaxX = Math.min(cell.maxX, cellMinX + cell.cellW);
      const cellMaxY = Math.min(cell.maxY, cellMinY + cell.cellH);

      let best = null;
      let bestD = -1;

      for(let i=0;i<30;i++){
        const pt = {
          x: cellMinX + Math.random()*Math.max(0,(cellMaxX - cellMinX)),
          y: cellMinY + Math.random()*Math.max(0,(cellMaxY - cellMinY))
        };
        if(forbid.some(fr => intersects(candidateRect(pt), fr))) continue;
        const d = (last.x === null) ? 0 : Math.hypot(pt.x - last.x, pt.y - last.y);
        if(d > bestD){ bestD = d; best = pt; }
      }

      if(!best){
        for(let i=0;i<120;i++){
          const pt = randInBounds();
          if(!forbid.some(fr => intersects(candidateRect(pt), fr))){
            best = pt; break;
          }
        }
      }

      if(!best) best = randInBounds();
      last = best;
      return best;
    }

    function place(){
      const pos = randomPos();
      target.style.left = pos.x + 'px';
      target.style.top  = pos.y + 'px';
    }

    function showFinal(){
      target.style.display = 'none';
      final.style.display = 'flex';
      hintBtn.disabled = true;
    }
    function hideFinal(){
      final.style.display = 'none';
      hintBtn.disabled = false;
    }

    function next(){
      const total = Math.max(1, cfg.rounds|0);
      if(found >= total){ showFinal(); return; }
      hideFinal();
      target.style.display = '';

      target.classList.remove('fx-none','fx-fade','fx-pop','fx-slide','fx-wiggle','fx-softfade','fx-hint');
      void target.offsetWidth;

      setAnim();
      place();
      updateUI();
    }

    function runHint(){
      if(final.style.display === 'flex') return;

      const wasHidden = (target.style.display === 'none');
      if(wasHidden) target.style.display = '';

      target.classList.remove('fx-hint');
      void target.offsetWidth;
      target.classList.add('fx-hint');

      setTimeout(()=>{
        target.classList.remove('fx-hint');
        if(wasHidden) target.style.display = 'none';
      }, 2000);
    }

    root.style.position = 'relative';
    root.style.background = 'transparent';

    img.referrerPolicy = 'no-referrer';
    img.src = cfg.url || '';

    target.style.width  = (cfg.size|0) + 'px';
    target.style.height = (cfg.size|0) + 'px';

    hintBtn.addEventListener('click', runHint);

    target.addEventListener('click', ()=>{
      const total = Math.max(1, cfg.rounds|0);
      if(found >= total) return;
      found++;
      updateUI();
      target.style.display = 'none';
      setTimeout(next, Math.max(0, cfg.gap|0));
    });

    const ro = ('ResizeObserver' in window) ? new ResizeObserver(()=>{ if(target.style.display!=='none') place(); }) : null;
    if(ro) ro.observe(root);
    window.addEventListener('resize', ()=>{ if(target.style.display!=='none') place(); }, {passive:true});

    updateUI();
    next();
  })();
  <\/script>
</div>`;
  }

  function currentCfg(){
    return {
      url: (imgUrl.value || "").trim(),
      size: Math.max(18, Math.min(320, +size.value || 46)),
      rounds: Math.max(1, Math.min(99, +rounds.value || 7)),
      anim: anim.value,
      dur: Math.max(0, Math.min(3000, +dur.value || 0)),
      pad: Math.max(0, Math.min(240, +pad.value || 0)),
      gap: Math.max(0, Math.min(8000, +gap.value || 0)),
      task: (taskText.value || "").trim(),
      endText: (endText.value || "").trim()
    };
  }

  async function testImage(url){
    return new Promise((resolve)=>{
      if(!url){ resolve({ok:false, msg:""}); return; }
      const i = new Image();
      i.onload = ()=> resolve({ok:true, msg:"‚úì –∫–∞—Ä—Ç–∏–Ω–∫–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–∞"});
      i.onerror = ()=> resolve({ok:false, msg:"‚ö†Ô∏è –Ω–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∫–∞—Ä—Ç–∏–Ω–∫—É (–ø—Ä–æ–≤–µ—Ä—å URL)"});
      i.referrerPolicy = "no-referrer";
      i.src = url;
    });
  }

  async function apply(){
    updateTexts();
    setTargetSize(+size.value || 46);
    setAnim();
    updateProgress();

    const url = (imgUrl.value || "").trim();
    targetImg.referrerPolicy = "no-referrer";
    targetImg.src = url;

    const res = await testImage(url);
    imgStatus.textContent = res.msg;

    // –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ ‚Äî —Å–±—Ä–æ—Å –ø–∞–º—è—Ç–∏ –º–µ—Å—Ç (–∏–Ω–∞—á–µ –º–æ–∂–µ—Ç –±—ã—Ç—å ‚Äú–º–∞–ª–æ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —è—á–µ–µ–∫‚Äù)
    usedCells.clear();

    if(target.style.display !== "none") place();
  }

  imgUrl.addEventListener("change", apply);
  size.addEventListener("input", apply);
  rounds.addEventListener("change", ()=>{ apply(); updateProgress(); });
  anim.addEventListener("change", apply);
  dur.addEventListener("change", apply);
  pad.addEventListener("change", apply);
  gap.addEventListener("change", apply);
  taskText.addEventListener("input", updateTexts);
  endText.addEventListener("input", updateTexts);

  $("reset").addEventListener("click", resetGame);

  $("getCode").addEventListener("click", ()=>{
    const cfg = currentCfg();
    codeBox.value = buildWidgetCode(cfg);
    codeBox.focus();
    codeBox.select();
  });

  $("copyCode").addEventListener("click", async ()=>{
    if(!codeBox.value.trim()){
      const cfg = currentCfg();
      codeBox.value = buildWidgetCode(cfg);
    }
    try{
      await navigator.clipboard.writeText(codeBox.value);
      imgStatus.textContent = "‚úì –∫–æ–¥ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω";
    }catch(e){
      codeBox.focus(); codeBox.select();
      imgStatus.textContent = "‚ö†Ô∏è –Ω–µ —Å–º–æ–≥ —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ ‚Äî –≤—ã–¥–µ–ª–∏–ª–∞ –∫–æ–¥, –Ω–∞–∂–º–∏ Cmd+C";
    }
  });

  hintBtn.addEventListener("click", runHint);

  target.addEventListener("click", ()=>{
    const total = Math.max(1, +rounds.value || 1);
    if(found >= total) return;
    found++;
    updateProgress();
    target.style.display = "none";
    setTimeout(next, Math.max(0, +gap.value || 0));
  });

  // INIT
  imgUrl.value = DEFAULT_URL;
  targetImg.src = DEFAULT_URL;
  updateTexts();
  resetGame();
</script>
</body>
</html>
